// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package model

import (
	"fmt"
	"strings"
)

const (
	// CredentialUuid is a Credential of type Uuid.
	CredentialUuid Credential = iota
	// CredentialPassword is a Credential of type Password.
	CredentialPassword
	// CredentialLogin is a Credential of type Login.
	CredentialLogin
	// CredentialUserId is a Credential of type User_id.
	CredentialUserId
	// CredentialCreatedAt is a Credential of type Created_at.
	CredentialCreatedAt
	// CredentialUpdatedAt is a Credential of type Updated_at.
	CredentialUpdatedAt
)

var ErrInvalidCredential = fmt.Errorf("not a valid Credential, try [%s]", strings.Join(_CredentialNames, ", "))

const _CredentialName = "uuidpasswordloginuser_idcreated_atupdated_at"

var _CredentialNames = []string{
	_CredentialName[0:4],
	_CredentialName[4:12],
	_CredentialName[12:17],
	_CredentialName[17:24],
	_CredentialName[24:34],
	_CredentialName[34:44],
}

// CredentialNames returns a list of possible string values of Credential.
func CredentialNames() []string {
	tmp := make([]string, len(_CredentialNames))
	copy(tmp, _CredentialNames)
	return tmp
}

// CredentialValues returns a list of the values for Credential
func CredentialValues() []Credential {
	return []Credential{
		CredentialUuid,
		CredentialPassword,
		CredentialLogin,
		CredentialUserId,
		CredentialCreatedAt,
		CredentialUpdatedAt,
	}
}

var _CredentialMap = map[Credential]string{
	CredentialUuid:      _CredentialName[0:4],
	CredentialPassword:  _CredentialName[4:12],
	CredentialLogin:     _CredentialName[12:17],
	CredentialUserId:    _CredentialName[17:24],
	CredentialCreatedAt: _CredentialName[24:34],
	CredentialUpdatedAt: _CredentialName[34:44],
}

// String implements the Stringer interface.
func (x Credential) String() string {
	if str, ok := _CredentialMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Credential(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Credential) IsValid() bool {
	_, ok := _CredentialMap[x]
	return ok
}

var _CredentialValue = map[string]Credential{
	_CredentialName[0:4]:   CredentialUuid,
	_CredentialName[4:12]:  CredentialPassword,
	_CredentialName[12:17]: CredentialLogin,
	_CredentialName[17:24]: CredentialUserId,
	_CredentialName[24:34]: CredentialCreatedAt,
	_CredentialName[34:44]: CredentialUpdatedAt,
}

// ParseCredential attempts to convert a string to a Credential.
func ParseCredential(name string) (Credential, error) {
	if x, ok := _CredentialValue[name]; ok {
		return x, nil
	}
	return Credential(0), fmt.Errorf("%s is %w", name, ErrInvalidCredential)
}

// MarshalText implements the text marshaller method.
func (x Credential) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *Credential) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseCredential(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// TableUser is a Table of type User.
	TableUser Table = iota
	// TableGroup is a Table of type Group.
	TableGroup
	// TableInterest is a Table of type Interest.
	TableInterest
	// TableCredential is a Table of type Credential.
	TableCredential
	// TableUserInterest is a Table of type User_interest.
	TableUserInterest
	// TableGroupInterest is a Table of type Group_interest.
	TableGroupInterest
)

var ErrInvalidTable = fmt.Errorf("not a valid Table, try [%s]", strings.Join(_TableNames, ", "))

const _TableName = "usergroupinterestcredentialuser_interestgroup_interest"

var _TableNames = []string{
	_TableName[0:4],
	_TableName[4:9],
	_TableName[9:17],
	_TableName[17:27],
	_TableName[27:40],
	_TableName[40:54],
}

// TableNames returns a list of possible string values of Table.
func TableNames() []string {
	tmp := make([]string, len(_TableNames))
	copy(tmp, _TableNames)
	return tmp
}

// TableValues returns a list of the values for Table
func TableValues() []Table {
	return []Table{
		TableUser,
		TableGroup,
		TableInterest,
		TableCredential,
		TableUserInterest,
		TableGroupInterest,
	}
}

var _TableMap = map[Table]string{
	TableUser:          _TableName[0:4],
	TableGroup:         _TableName[4:9],
	TableInterest:      _TableName[9:17],
	TableCredential:    _TableName[17:27],
	TableUserInterest:  _TableName[27:40],
	TableGroupInterest: _TableName[40:54],
}

// String implements the Stringer interface.
func (x Table) String() string {
	if str, ok := _TableMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Table(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Table) IsValid() bool {
	_, ok := _TableMap[x]
	return ok
}

var _TableValue = map[string]Table{
	_TableName[0:4]:   TableUser,
	_TableName[4:9]:   TableGroup,
	_TableName[9:17]:  TableInterest,
	_TableName[17:27]: TableCredential,
	_TableName[27:40]: TableUserInterest,
	_TableName[40:54]: TableGroupInterest,
}

// ParseTable attempts to convert a string to a Table.
func ParseTable(name string) (Table, error) {
	if x, ok := _TableValue[name]; ok {
		return x, nil
	}
	return Table(0), fmt.Errorf("%s is %w", name, ErrInvalidTable)
}

// MarshalText implements the text marshaller method.
func (x Table) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *Table) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseTable(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// UserId is a User of type Id.
	UserId User = iota
	// UserNickname is a User of type Nickname.
	UserNickname
	// UserName is a User of type Name.
	UserName
	// UserSurname is a User of type Surname.
	UserSurname
	// UserPfpId is a User of type Pfp_id.
	UserPfpId
	// UserAbout is a User of type About.
	UserAbout
	// UserContacts is a User of type Contacts.
	UserContacts
	// UserCreatedAt is a User of type Created_at.
	UserCreatedAt
	// UserUpdatedAt is a User of type Updated_at.
	UserUpdatedAt
)

var ErrInvalidUser = fmt.Errorf("not a valid User, try [%s]", strings.Join(_UserNames, ", "))

const _UserName = "idnicknamenamesurnamepfp_idaboutcontactscreated_atupdated_at"

var _UserNames = []string{
	_UserName[0:2],
	_UserName[2:10],
	_UserName[10:14],
	_UserName[14:21],
	_UserName[21:27],
	_UserName[27:32],
	_UserName[32:40],
	_UserName[40:50],
	_UserName[50:60],
}

// UserNames returns a list of possible string values of User.
func UserNames() []string {
	tmp := make([]string, len(_UserNames))
	copy(tmp, _UserNames)
	return tmp
}

// UserValues returns a list of the values for User
func UserValues() []User {
	return []User{
		UserId,
		UserNickname,
		UserName,
		UserSurname,
		UserPfpId,
		UserAbout,
		UserContacts,
		UserCreatedAt,
		UserUpdatedAt,
	}
}

var _UserMap = map[User]string{
	UserId:        _UserName[0:2],
	UserNickname:  _UserName[2:10],
	UserName:      _UserName[10:14],
	UserSurname:   _UserName[14:21],
	UserPfpId:     _UserName[21:27],
	UserAbout:     _UserName[27:32],
	UserContacts:  _UserName[32:40],
	UserCreatedAt: _UserName[40:50],
	UserUpdatedAt: _UserName[50:60],
}

// String implements the Stringer interface.
func (x User) String() string {
	if str, ok := _UserMap[x]; ok {
		return str
	}
	return fmt.Sprintf("User(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x User) IsValid() bool {
	_, ok := _UserMap[x]
	return ok
}

var _UserValue = map[string]User{
	_UserName[0:2]:   UserId,
	_UserName[2:10]:  UserNickname,
	_UserName[10:14]: UserName,
	_UserName[14:21]: UserSurname,
	_UserName[21:27]: UserPfpId,
	_UserName[27:32]: UserAbout,
	_UserName[32:40]: UserContacts,
	_UserName[40:50]: UserCreatedAt,
	_UserName[50:60]: UserUpdatedAt,
}

// ParseUser attempts to convert a string to a User.
func ParseUser(name string) (User, error) {
	if x, ok := _UserValue[name]; ok {
		return x, nil
	}
	return User(0), fmt.Errorf("%s is %w", name, ErrInvalidUser)
}

// MarshalText implements the text marshaller method.
func (x User) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *User) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseUser(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
